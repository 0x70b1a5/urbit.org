+++
title = "Cryptography"
weight = 10
template = "doc.html"
+++

Cryptography is central to the operation of Urbit. This section gives an
overview of where cryptographic methods are utilized in Arvo, Azimuth, and Vere,
what they are, and how they are implemented.

This document does not describe any algorithmic details of cryptographic
functions, only how they are utilized. This document also does not yet cover
hashing - see [Insecure Hashing](@/docs/hoon/reference/stdlib/2e.md) and [SHA
Hash Family](@/docs/reference/stdlib/3d.md) for reference material on hash
functions in the standard library.

## Summary

There are two categories of keys and five parts of the system involved with
cryptography on Urbit. We summarize each component here briefly, and then
continue with a more detailed exposition below.

### Types of keys

The two categories of keys are your Azimuth/Ethereum keys and your networking
keys. In both cases, these are public/private key pairs utilized for public key
cryptography.

#### Azimuth keys

Your Urbit ID exists as an ERC-721 non-fungible token on the Ethereum
blockchain, and as such is contained in a wallet whose private key you possess.
If you are are utilizing a [master
ticket](@/docs/azimuth/azimuth.md#master-ticket), this private key is derived
from a seed, which is what you use to login to
[Bridge](@/docs/glossary/bridge.md). Otherwise, you have generated the key by
some other process, of which there are too many to list here. Besides the
private key which unlocks your ownership wallet address, you may have a few
other private keys which unlock a wallet that corresponds to your ship's
[proxies](@/docs/glossary/proxies.md). We refer collectively to these keys as
your _Azimuth keys_.

Only [planets](@/docs/glossary/planet.md), [stars](@/docs/glossary/star.md), and
[galaxies](@/docs/glossary/galaxy.md) have Azimuth keys.
[Moons](@/docs/glossary/moon.md) and [comets](@/docs/glossary/comet.md) do not,
as they do not utilize the Ethereum blockchain.

It is important to note that no Azimuth keys are stored anywhere within your
ship's [pier](@/docs/glossary/pier.md) - Ethereum and Urbit ID are entirely
separate entities from Urbit itself, and so you lose access to your Azimuth
private keys there is no way to retrieve them somehow from your ship.

For more information on the usage of these keys and the associated proxies, see
the [Azimuth documentation](@/docs/azimuth/azimuth.md).

#### Networking keys

All communications in Urbit over the [Ames](@/docs/glossary/ames.md) are
end-to-end encrypted, and thus your ship stores a public/private pair of
_networking keys_ utilized to manage that encryption. Networking keys for all
ship types are stored within the ship's Jael vane (see the following section).

For planets, stars, and galaxies, your private networking key is a
necessary input (the [keyfile](@/docs/glossary/keyfile.md)) for the initial boot
sequence of your ship (sometime called its `%dawn`). The associated public key
is then uploaded to the Ethereum blockchain using one of your Azimuth private
keys - either the one associated to the wallet which owns the ship, or the one
which holds the management proxy.

For moons, the private networking key is generated by the parent ship and
injected into the `%dawn` sequence for the moon, and its public key is stored by
the parent in its Jael vane. Moon networking keys may be changed by the parent
ship, but not by the moon itself.

For comets, their 128-bit `@p` name is actually their public key, and the
"mining" process to generate a comet consists of guessing a private key for
which the associated public key has a galaxy that has already been pre-assigned
to assist its peer discovery process. Thus, comets cannot change their
networking keys - to get a new private networking key, a new comet must be
generated.

### System components

[Ames](@/docs/arvo/ames/ames.md) is Arvo's networking vane. All packets sent by
Ames are encrypted utilizing a cryptosuite found in `zuse`. The only exception
to this are comet self-attestation packets utilized to transmit their public
key. Ames is responsible for encryption and decryption of all packets. By
default, this utilizes AES symmetric key encryption, whose shared private key is
got by elliptic curve Diffie-Hellman key exchange.

`zuse` is the Hoon standard library. It contains cryptographic primitives which
are utilized by Ames. All cryptographic primitives are
[jetted](@/docs/vere/jetting.md) in Vere with standard vetted implementations of
cryptographic libraries.

[Vere](@/docs/vere/_index.md) is Urbit's Nock runtime system, written in C.
Correct implementation of cryptographic libraries is difficult, and so all
cryptographic primitives implemented in Hoon actually hinted to the interpreter
to run vetted cryptographic libraries reviewed by experts instead.

[Jael](@/docs/arvo/jael/jael-api.md) is primarily utilized for the safe storage
of private keys and retrieval of public keys utilized by Ames. The Jael vane of
a planet is responsible for distributing the public keys of its moons
(ultimately via Ames), while the Jael vane of a comet is responsible for
distributing its own public key (also ultimately via Ames).

[Azimuth](@/docs/azimuth/_index.md) is Urbit's Ethereum-based public key
infrastructure. `azimuth-tracker` obtains networking public keys for planets,
stars, and galaxies from this store, which are then stored in Jael and utilized
by Ames for end-to-end encrypted communication. It is important to note that the
private keys which generate the wallet that holds ownership of your Urbit ID and
its proxies are not stored anywhere on your ship.

## Ames

The `$ames-state` includes a `+crypto-core`, an interface core into which one of
the cryptosuites in `zuse` may be implemented. The suite utilized by the
`+crypto-core` is used to encrypt all communications utilized by Ames. By
default, all packets are encrypted with AES symmetric key encryption, whose key
is got by Diffie-Hellman key exchange, with public/private keys generated using
elliptic curve ed25519.

### +crypto-core {#crypto-core}

The `+crypto-core` is an `+acru:ames` core, a
[lead](@/docs/hoon/reference/advanced.md#dry-polymorphism-and-core-nesting-rules)
interface core for asymmetric cryptosuites found in `sys/zuse.hoon` which
handles encryption, decryption, signing, and verifying. In practice, the only
cryptosuite in use is [`+crub:crypto`](#crub), which implements [Suite B
Cryptography](https://en.wikipedia.org/wiki/NSA_Suite_B_Cryptography). Under
most circumstances, all asymmetric encryption- and signing-related tasks done
within Urbit should be mediated via an `+acru` interface.

```hoon
  ++  acru  $_  ^?                                      ::  asym cryptosuite
    |%                                                  ::  opaque object
    ++  as  ^?                                          ::  asym ops
      |%  ++  seal  |~([a=pass b=@] *@)                 ::  encrypt to a
          ++  sign  |~(a=@ *@)                          ::  certify as us
          ++  sure  |~(a=@ *(unit @))                   ::  authenticate from us
          ++  tear  |~([a=pass b=@] *(unit @))          ::  accept from a
      --  ::as                                          ::
    ++  de  |~([a=@ b=@] *(unit @))                     ::  symmetric de, soft
    ++  dy  |~([a=@ b=@] *@)                            ::  symmetric de, hard
    ++  en  |~([a=@ b=@] *@)                            ::  symmetric en
    ++  ex  ^?                                          ::  export
      |%  ++  fig  *@uvH                                ::  fingerprint
          ++  pac  *@uvG                                ::  default passcode
          ++  pub  *pass                                ::  public key
          ++  sec  *ring                                ::  private key
      --  ::ex                                          ::
    ++  nu  ^?                                          ::  reconstructors
      |%  ++  pit  |~([a=@ b=@] ^?(..nu))               ::  from [width seed]
          ++  nol  |~(a=ring ^?(..nu))                  ::  from ring
          ++  com  |~(a=pass ^?(..nu))                  ::  from pass
      --  ::nu                                          ::
    --  ::acru                                          ::
```

As the `+acru` core is merely an interface, the details on how it is utilized
may vary according to the cryptosuite implemented in it. We summarize what each
core is utilized for here, but see [`crub:crypto`](#crub) for more details on
how the specific cryptosuite utilized by Ames is implemented.

#### `+as:acru`

This core is used for the standard asymmetric cryptographic operations: encrypting
(`+seal`), signing (`+sign`), authenticating (`+sure`), and decrypting (`+tear`).

#### `+ex:acru`

This core stores keys and their fingerprints. `+sec` is the secret key (which
may be empty), `+pub` is the public key associated to the secret key, `+pac` is
the fingerprint associated to the secret key, and `+fig` is the fingerprint
associated to the public key. We note that when the core contains both
encryption and authentication keys, they are typically concatenated to be
returned as a single atom.

#### `+nu:acru`

This core contains constructors for the `+acru` core. `+pit:nu` is used to
construct an `+acru` core with both a private and public key (i.e. both
`+sec:ex` and `pub:ex` are set) from a bitlength and seed. `+nol:nu` can then be
called from an `+acru` core created with `+pit:nu` to get an `+acru` core with
only the secret key, while `+com:nu` can be called to get an `+acru` core with
only the public key.

#### `+de`, `+dy`, `+en`

These arms are for symmetric encryption and decryption. In case of failure,
`+de` returns null and `+dy` crashes.


### Diffie-Hellman key exchange {#key-exchange}

For each `@p` a given ship has met, `$ames-state` contains a `$peer-state`,
inside which the `$symmetric-key` (an atom which nests under `@uw`) utilized for
encrypting all Ames packets shared between the two ships. The `symmetric-key` is
derived using `shar:ed:crypto` found in `sys/zuse.hoon`, which is an arm
utilized for generating the symmetric key for elliptic curve Diffie-Hellman key
exchange with [curve25519](https://en.wikipedia.org/wiki/Curve25519); see
[below](#ed) for more information on the `ed:crypto` core.

### Packet encryption

The encrypted payload of each packet is a `$shut-packet`, which is the `+jam` of
a cell with the `bone`, message number, and message fragment or ack (see
[Ames](@/docs/ames/ames.md) for more information on packet structure). It is
encrypted using `++sivc:aes:crypto` found in `sys/zuse.hoon`, which is an arm
utilized for 256-bit AES SIV symmetric encryption; see [below](#aes) for more
information on the `aes:crypto` core.

### Comet self-attestation

Recall that the `@p` of a comet is simply casting their 128-bit public key as a
`@p`. Since the public key of a comet is not stored on Azimuth, a comet proves
its identity with an "attestation packet". This is an unencrypted packet whose
payload contains the comet's signature created with its private key. This is the
only situation in which a ship will send an unencrypted packet. The signature is
generated with `sign:as:acru`, and thus which signature algorithm is utilized
depends on the `+crypto-core`.

Upon hearing an attestation packet, the receiving ship will generate a symmetric
key for communications with the comet, according to the [key
exchange](#key-exchange) protocol.

The fact that the first packet exchanged between a comet and another ship must
be an attestation packet is why comets are unable to initiate communication with
one another, and also why comets must be the first to initiate communication
with a non-comet.


## `zuse`

`zuse` contains several cryptosuites. The only ones currently in use are
`+ed:crypto`, `+aes:crypto`, and `+crub:crypto`, with the latter being the
only one which is implementable as an `+acru` core.

### `+ed:crypto` {#ed}

See also the section on Ed25519 for [Vere](#vere-ed).

### `+aes:crypto` {#aes}

See also the section on AES SIV for [Vere](#vere-aes).

### `+crub:crypto` {#crub}

`+crub:crypto` is a gate which creates an `+acru` core that implements [Suite B
Cryptography](https://en.wikipedia.org/wiki/NSA_Suite_B_Cryptography).

It utilizes AES symmetric key encryption and decryption from `+aes:crypto`
implemented using the Diffie-Hellman key exchange protocol, elliptic curve
digital signature algorithm (ECDSA) signing and verification with `+ed:crypto`,
and generates public/private key pairs using elliptic curve cryptography with
`+ed:crypto`.

`+crub:crypto` is called with public encryption and authentication keys and
optional secret encryption and authentication keys.
```hoon
  ++  crub  !:
    ^-  acru
    =|  [pub=[cry=@ sgn=@] sek=(unit [cry=@ sgn=@])]
    |%
    ...
```
`+crub` cores are typically not created by directly calling the gate, but
instead using one of the constructors in `+nu:crub`.

#### `+seal:as`

```hoon
      ++  seal                                          ::
        |=  [bpk=pass msg=@]
        ...
```

Forms a symmetric key using Diffie-Hellman key exchange with the secret key
stored at `sgn.u.sek` and a public key `bpk`. Then `+sign`s `msg`, encrypts the
signed message using `+en:siva:aes` with the symmetric key, and then `+jam`s it.

Crashes if `sek` is null.

#### `+sign:as`

```hoon
      ++  sign                                          ::
        |=  msg=@
        ...
```

Signs message `msg=@` using the secret authentication key `sgn.u.sek`, then forms a
cell `[signed-message msg]` and `+jam`s it.

Crashes if `sek` is null.

#### `+sure:as`

```hoon
      ++  sure                                          ::
        |=  txt=@
        ...
```

`+cue`s `txt` to get a signature `sig=@` and message `msg=@`. Verifies that
`sig` was `msg` signed using the secret key associated to the public key stored
at `sgn.pub`. Returns `(unit msg)` if so, null otherwise.

#### `+tear:as`

```hoon
      ++  tear                                          ::
        |=  [bpk=pass txt=@]
        ...
```

Forms a secret symmetric key using Diffie-Hellman key exchange using the secret
key `cry.u.sek` and encryption key part of the public key `bpk` (which here is a
concatenation of both the encryption and authentication public keys). `+cue`s
`txt` and decrypts it using `+de:siva:aes` with the symmetric key. If decryption
is successful, verifies the decrypted message using authentication key part of
`bpk`, and returns it if so. Returns null otherwise.

Crashes if `sek` is null.

#### `+de`

```hoon
    ++  de                                              ::  decrypt
      |=  [key=@J txt=@]
      ...
```

`+cue`s `txt` then decrypts with the symmetric key `key` using `de:sivc:aes`.
Returns null in case of failure.

#### `+dy`

```hoon
    ++  dy                                              ::  need decrypt
      |=  [key=@J cph=@]
      ...
```

Same as `+dy`, but crashes in case of failure.

#### `+en`

```hoon
    ++  en                                              ::  encrypt
      |=  [key=@J msg=@]
```

Encrypts `msg` with the symmetric key `key` using `en:sivc:aes`, then `+jam`s
it.

#### `+fig:ex`

Returns the fingerprint (SHA-256) of `+pub:ex`.

#### `+pac:ex`

Returns the fingerprint (SHA-256) of `+sec:ex`. Crashes if `sek` is null.

#### `+pub:ex`

Returns the concatenation of `sgn.pub` and `cry.pub`.

#### `+sec:ex`

Returns the concatenation of `sgn.u.sek` and `cry.u.sek`.

#### `+pit:nu`

```hoon
      ++  pit                                           ::  create keypair
        |=  [w=@ seed=@]
        ...
```

Creates a `+crub` core with encryption and authentication public/private keypairs
generated from a bitwidth `w` and `seed`. The private keys are generated with
SHA-512, while `+puck:ed:crypto` is used to derive the public keys from the
private keys.

This is how one typically generates a brand new `+crub` core for signing and
encrypting your own messages.

#### `+nol:nu`

```hoon
      ++  nol                                           ::  activate secret
        |=  a=ring
        ...
```

Takes in a `ring` from a `+sec:ex:crub` and generates a new `+crub` core with
`sek` taken from `+sec:ex` and `pub` generated with `+puck:ed:crypto`. Crashes
if `+sec:ex` is not a `+crub` secret key.

#### `+com:nu`

```hoon
      ++  com                                           ::  activate public
        |=  a=pass
        ...
```

Takes in a `pass` from a `+pub:ex:crub` and generates a new `+crub` core with
`pub` taken from `+pub:ex` and null `sek`.

### `+secp:crypto` {#secp}

Utilized for secp256k1 (Ethereum public and private keys).


## Vere

All cryptographic primitives utilized by Arvo are
[jetted](@/docs/vere/jetting.md). This is done for performance-related reasons
in other parts of the system, but for cryptography this is also extremely
important because it allows us to utilize standard reference implementations for
the primitives written in C.

All jets related to encryption may be found in `pkg/urbit/jets/e/`.

In this section we review what specific implementations are utilized.

### Ed25519 {#vere-ed}

Urbit implements [Ed25519](http://ed25519.cr.yp.to/) based on the SUPERCOP
"ref10" implementation. Additionally there is key exchanging and scalar addition
included to further aid building a PKI using Ed25519. All code is licensed under
the permissive zlib license.

All code is pure ANSI C without any dependencies, except for the random seed
generation which uses standard OS cryptography APIs (CryptGenRandom on Windows,
`/dev/urandom` on nix).

### AES SIV {#vere-aes}

The library we utilize for AES SIV is an
[RFC5297](https://tools.ietf.org/html/rfc5297)-compliant C implementation of
AES-SIV written by Daniel Franke on behalf of [Akamai
Technologies](https://www.akamai.com). It is published under the [Apache License
(v2.0)](https://www.apache.org/licenses/LICENSE-2.0). It uses OpenSSL for the
underlying [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) and
[CMAC](https://en.wikipedia.org/wiki/One-key_MAC) implementations and follows a
similar interface style.

While the jets are found in `pkg/urbit/jets/e`, the statically-linked package is
found at `pkg/libas_siv/`.






